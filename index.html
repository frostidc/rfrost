<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <title>Rclose Pixel Place - Full Admin</title>
  <style>
    body { background: #111; color: white; text-align: center; font-family: sans-serif; }
    canvas { border: 2px solid #fff; margin-top: 20px; image-rendering: pixelated; cursor: crosshair; }
    #colorPicker { margin: 10px; }
    button, input[type="file"] {
      padding: 10px;
      margin: 5px;
      background: #333;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h1>ðŸŽ¨ Rclose Pixel Place</h1>

  <input type="color" id="colorPicker" value="#ff0000" />
  <canvas id="canvas" width="1000" height="1000"></canvas>

  <div id="adminPanel">
    <h3>ðŸ‘‘ Admin Panel</h3>
    <button id="clearBtn">ðŸ§¹ Tuvali Temizle</button><br />
    <input type="file" id="imageUpload" accept="image/*" />
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { getDatabase, ref, set, onValue, remove } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";

    const firebaseConfig = {
      apiKey: "AIzaSyDAJGgwGdI6ZgWaGkZfIT9WRcbBqHLUXWY",
      authDomain: "rclose-25d84.firebaseapp.com",
      projectId: "rclose-25d84",
      storageBucket: "rclose-25d84.firebasestorage.app",
      messagingSenderId: "697784540299",
      appId: "1:697784540299:web:a8425786862a02459a088e",
      measurementId: "G-ELTFR1KTWP",
      databaseURL: "https://rclose-25d84-default-rtdb.firebaseio.com"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const gridSize = 10;

    // Firebase'den tÃ¼m pikselleri oku ve Ã§iz
    const pixelRef = ref(db, 'pixels');
    onValue(pixelRef, (snapshot) => {
      const data = snapshot.val();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (data) {
        for (let key in data) {
          const [x, y] = key.split('_').map(Number);
          ctx.fillStyle = data[key];
          ctx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);
        }
      }
    });

    // Normal kullanÄ±cÄ± iÃ§in piksel boyama
    canvas.addEventListener("click", (e) => {
      if (pendingImageData) {
        // EÄŸer admin resim yerleÅŸtiriyorsa onu baÅŸlat
        placeImageAtClick(e);
      } else {
        drawPixel(e);
      }
    });

    function drawPixel(e) {
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - rect.left) / gridSize);
      const y = Math.floor((e.clientY - rect.top) / gridSize);
      const color = document.getElementById("colorPicker").value;
      const pixelKey = `${x}_${y}`;
      ctx.fillStyle = color;
      ctx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);
      set(ref(db, 'pixels/' + pixelKey), color);
    }

    // Tuvali temizle butonu
    document.getElementById("clearBtn").onclick = () => {
      if (confirm("Tuvali tamamen temizlemek istiyor musun?")) {
        remove(ref(db, 'pixels'));
      }
    };

    // Admin resim yerleÅŸtirmek iÃ§in veriler burada tutulacak
    let pendingImageData = null; // { imageData: Uint8ClampedArray, width: int, height: int }
    let pendingImageDrawn = false;

    // Resim yÃ¼kleme ve Ã¶n hazÄ±rlÄ±k
    document.getElementById("imageUpload").addEventListener("change", (event) => {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          const maxCellsX = Math.floor(canvas.width / gridSize);
          const maxCellsY = Math.floor(canvas.height / gridSize);

          let imgW = img.width;
          let imgH = img.height;

          // EÄŸer resim tuvalden bÃ¼yÃ¼kse orantÄ±lÄ± kÃ¼Ã§Ã¼lt
          if (imgW > maxCellsX || imgH > maxCellsY) {
            const scale = Math.min(maxCellsX / imgW, maxCellsY / imgH);
            imgW = Math.floor(imgW * scale);
            imgH = Math.floor(imgH * scale);
          }

          const tempCanvas = document.createElement("canvas");
          tempCanvas.width = imgW;
          tempCanvas.height = imgH;
          const tempCtx = tempCanvas.getContext("2d");
          tempCtx.drawImage(img, 0, 0, imgW, imgH);
          const imageData = tempCtx.getImageData(0, 0, imgW, imgH).data;

          pendingImageData = { imageData, width: imgW, height: imgH };
          pendingImageDrawn = false;
          alert(`ðŸŸ¡ Resim yÃ¼klendi (${imgW}x${imgH}). Tuvale tÄ±klayarak Ã§izime baÅŸla.`);
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    });

    // Adminin tÄ±kladÄ±ÄŸÄ± yerden resim Ã§izme fonksiyonu
    function placeImageAtClick(e) {
      if (!pendingImageData) return;

      const rect = canvas.getBoundingClientRect();
      const startX = Math.floor((e.clientX - rect.left) / gridSize);
      const startY = Math.floor((e.clientY - rect.top) / gridSize);

      const { imageData, width, height } = pendingImageData;

      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const idx = (y * width + x) * 4;
          const r = imageData[idx];
          const g = imageData[idx + 1];
          const b = imageData[idx + 2];
          const a = imageData[idx + 3];

          // EÄŸer piksel ÅŸeffaf deÄŸilse Ã§iz
          if (a > 128) {
            const hex = rgbToHex(r, g, b);
            const pixelX = startX + x;
            const pixelY = startY + y;

            // Tuval sÄ±nÄ±rlarÄ±nÄ± aÅŸma kontrolÃ¼
            if (pixelX >= 0 && pixelX < canvas.width / gridSize &&
                pixelY >= 0 && pixelY < canvas.height / gridSize) {

              ctx.fillStyle = hex;
              ctx.fillRect(pixelX * gridSize, pixelY * gridSize, gridSize, gridSize);
              set(ref(db, 'pixels/' + pixelX + '_' + pixelY), hex);
            }
          }
        }
      }

      pendingImageData = null; // Resim Ã§izimi tamamlandÄ±, temizle
      pendingImageDrawn = true;
    }

    // RGB'den HEX'e dÃ¶nÃ¼ÅŸtÃ¼rme fonksiyonu
    function rgbToHex(r, g, b) {
      return "#" + [r, g, b].map(x => x.toString(16).padStart(2, "0")).join("");
    }
  </script>
</body>
</html>
